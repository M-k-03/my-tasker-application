import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:my_tasker/models/product.dart';
import 'package:my_tasker/models/sale_entry.dart';
import 'package:my_tasker/models/cart_item.dart'; // Added import for CartItem

class SaleService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Constructor
  SaleService();

  // Updated to use SaleEntry and List<CartItem>
  Future<void> recordSaleAndUpdateStock(List<CartItem> cartItems) async { // Changed signature
    WriteBatch batch = _firestore.batch();
    Timestamp saleTimestamp = Timestamp.now(); // Use the same timestamp for all entries in this sale

    // 1. For each cartItem, create a SaleEntry document in 'sale_entries'.
    for (var item in cartItems) {
      // Create a new SaleEntry for THIS specific cart item
      SaleEntry entry = SaleEntry(
        // id will be auto-generated by .doc() if we don't supply one,
        // or we can generate one if needed for other purposes.
        // For simplicity, Firestore can auto-generate the document ID.
        productId: item.productId,
        productName: item.productName,
        sku: item.sku, // Assuming CartItem has sku
        quantitySold: item.quantity,
        pricePerUnitAtSale: item.price, // Assuming CartItem has price
        totalAmountForProduct: item.price * item.quantity,
        saleTimestamp: saleTimestamp, // Consistent timestamp
      );

      DocumentReference saleDocRef = _firestore.collection('sale_entries').doc(); // Corrected collection name
      batch.set(saleDocRef, entry.toMap());

      // 2. Update the stock of the corresponding product in 'master_products'.
      DocumentReference productDocRef = _firestore.collection('master_products').doc(item.productId);
      batch.update(productDocRef, {'currentStock': FieldValue.increment(-item.quantity)});
      print('DEBUG SaleService: Adding SaleEntry for ${item.productName} (Qty: ${item.quantity}) to batch.');
      print('DEBUG SaleService: Scheduling stock update for ${item.productName} by -${item.quantity} in batch.');
    }

    // 3. Commit the batch
    try {
      await batch.commit();
      print('Sale recorded and stock updated successfully for all items.');
    } catch (e) {
      print('Error during batch commit: ${e.toString()}');
      throw Exception('Failed to record sale or update stock: ${e.toString()}');
    }
  }



// You might add other methods here, e.g.,
  // Future<List<SaleEntry>> fetchSalesHistory() async { ... }
  // Future<SaleEntry?> getSaleEntryDetails(String saleEntryId) async { ... }
}
